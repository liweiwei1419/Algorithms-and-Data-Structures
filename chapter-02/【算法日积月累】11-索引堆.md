---
title: 【算法日积月累】11-索引堆
date: 2019-01-12 08:00:00
author: liwei
top: false
mathjax: true
summary: 本文介绍了索引堆。
categories: 算法与数据结构
tags:
  - 优先队列
permalink: algorithms-and-data-structures/index-heap
---

# 【算法日积月累】11-索引堆

### 6.8.1 为什么要引入索引堆这个数据结构？

在堆的一些操作过程中，不论是 insert 还是 extractMax 方法，都涉及了一些元素的交换操作，**交换数组中的元素的位置，在一些场景下性能消耗很大**。因此，我们可以在堆的内部实现一个索引数组，通过索引可以找到我们真正存放在数组中的元素，而索引所代表数据构成一个最大堆。这就是我们要引入索引堆的原因。

我们举一个可能不是很贴切的生活中的例子，我们要给一组学生按照身高进行排序，我们不用把他们全部喊出来让他们从矮到高排好，我们只要让他们报上自己的身高，在纸上做他们身高的比较就可以了。

我还想到一点：现在我们都进入了移动支付时代，我们购买物品不需要把真真实实的钱给商家，这种操作就很像我们引入索引堆的操作，我们通过1、自己账户上的钱减少2、商家用户账上的钱增多，这种方式实现了转账，给我们的生活带来了巨大的方便。一手交钱一首交货的时代已经不存在了，我们只会看到快递小哥把货送到你家，而不会有快递小哥把你的钱寄给卖家。相信很多人像我一样，出门带的现金已经很少很少了，甚至有些时候，我们出门根本可以不带钱。

- 实现要点：

1、引入一个 indexes 数组；

2、比较的时候，使用 indexs 所对应的 data 来进行比较，交换的是 index 的位置，我们内部的实现仍然从 1 号索引开始存放数据，但这一点对外部用户来说是不可知的；

**对于我们索引堆的使用者来说，他们只需要知道，这是一个数据结构，可以往里面存入数据，而每一次那出来的数据，都是当前已经存放在这个数据结构中最大的那个元素。**

3、我们完全可以直接使用我们之前实现的 MaxHeap 来实现最大堆。

- 索引堆要支持的操作： 在实现的时候，**要注意 insert(i,item) 的实现，不是任意位置的 i都可以 insert 的，一般有两种情况：1、insert 到使用者所认为的优先队列的尾部；2、insert 到刚刚出队的那个元素的位置，因为那个位置的数据“已经没有了”，这一点要好好体会**。

| shiftUp(int k)         | 将位于 indexes 数组中的索引为 k 的元素逐个上移。             |
| ---------------------- | ------------------------------------------------------------ |
| shiftDown(int k)       | 将位于 indexes 数组中的索引为 k 的元素逐个下。               |
| insert(i,item)         | **特别注意：这里的 i 是由使用者保证的，是业务相关的，不能完全从程序和语法的角度来判断  i 的合理性。** |
| extractMax()           | 将此时二叉堆中的最大的那个数据返回。                         |
| extractMaxIndex()      | 将此时二叉堆中的最大的那个数据对应的索引返回。               |
| getItem(int i)         | 获得索引为 i 的数据，通常这个数据是刚刚出队的索引，是由 extractMaxIndex() 方法来的。 |
| change(int i,int item) | 修改索引为 i 的数据的“优先级”。                              |

【多说两句】关于索引堆中的索引和数据

https://coding.imooc.com/learn/questiondetail/4945.html

## 6.9 索引堆的优化

### 6.9.1 索引堆的优化方法

我们想找一找在使用者认为的优先队列中指定索引的数据，在我们的 indexes 数组中，排在第几位，我们使用了遍历，这种做法效率是不高的。

Java 代码：

```java
for (int j = 1; j <= count; j++) {
    if (indexes[j] == i) {
        // 找到了 j
        shiftDown(j);
        shiftUp(j);
        return;
    }
}
```

我们可以通过引入一个反向查找数组，实现反向查找 indexes 数组中，值为 i 的那个元素排在了 indexes 的第几位，通过对 reverse 数组的维护，就使得我们对反向查找这件事情的时间复杂度降到了 $O(1)$。

- `reverse[i]` 表示索引 i 在 indexes（堆）中的位置。引入 reveres 数组的意义是，可以在执行 change 这个方法的时候，使用 `O(1)` 这个时间复杂度，直接找到。
- reverse 数组的性质：

性质1：如果 `indexes[i] = j`，那么 `reveres[j] = i`；

性质2：`indexes[reveres[i]] = i`，`reveres[index[i]] = i`。

- reveres 数组的概念其实并不难理解，大家只要把 reveres 这个数组自己填一下就会非常清楚了。

| 0       | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| :------ | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| data    | 15   | 17   | 19   | 13   | 22   | 16   | 28   | 30   | 41   | 62   |
| indexes | 10   | 9    | 5    | 7    | 8    | 6    | 2    | 4    | 3    | 1    |
| reverse | 10   | 7    | 9    | 8    | 3    | 6    | 4    | 5    | 2    | 1    |

怎么看这张表：

indexes[1] = 10，表示使用者认为的第 10 号数据，排在了优先队列的第 1 位，即 10 这个数字在 indexes 数组中的索引是 1，故 revers[10] = 1；

indexes[2] = 9，表示使用者认为的第 9 号数据，排在了优先队列的第 9 位，即 9 这个数字在 indexes 数组中的索引是 2，故 revers[9] = 2；

indexes[5] = 8，表示使用者认为的第 8 号数据，排在了优先队列的第 5 位，即 8 这个数字在 indexes 数组中的索引是 5，故 revers[8] = 5；

所以，revers 数组的作用就是：**通过使用者认为的索引数据，它在 indexes 数组形成的堆中的位置**。

- reverse 数组在 indexes 数组交换位置的时候，应该如何维护

下面我们来分析一下 indexes 数组如果交换了位置，reverse 数组要如何交换位置。

假如要交换 indexes 数组 3 和 4 的位置，那么此时 indexes[3] = 7 ，indexes[4] = 5 ，为了保证 reverse 数组的正确性，（我们暂时不去看表），就应该使得 reverse[7] = 3，reverse[5] = 4。

此时再去看表， reverse[7] = 4，reverse[5] = 3。怎么交换的，就很清楚了。reverse 数组是 indexes 数组映射以后的两个值交换。

### 6.9.2 索引堆的应用

- 实现**多路归并排序**

这部分的知识我是在参考资料1（《算法》（第4版）P204）中看到的。在这里做一个笔记。索引堆只存了 3 个元素，**索引堆不仅仅把我们要的那个数据拿出来了，并且还给出了这个数据在使用者眼里的索引的位置**。

- 图论中使用索引堆找到最小生成树

## 6.10 参考资料

1. 图书《算法》(第4版)， Algorithms Fourth Edition，作者：[美] Robert Sedgewick，[美] Kevin Wayne 著，谢路云 译，[图书配套网站](https://algs4.cs.princeton.edu/home/)
2. [慕课网 liuyubobobo 老师《算法与数据结构》课程](https://coding.imooc.com/class/71.html)以及对应的 [GitHub 代码仓库](https://github.com/liuyubobobo/Play-with-Algorithms)
3. [慕课网 liuyubobobo 老师《看得见的算法》课程](http://coding.imooc.com/class/138.html)以及对应的 [GitHub 代码仓库](